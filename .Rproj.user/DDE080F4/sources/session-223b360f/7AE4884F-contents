source("tab_coefficients.R")
library(tidyverse)
# funzioni per loglikelihood

compute_log_lik <- function(m_log_tau_vec, pred_vec){
  log_lik<-numeric(length(m_log_tau_vec))
  for(i in 1:length(m_log_tau_vec)){
    log_lik[i]<- - (m_log_tau_vec[i]-pred_vec[i])-exp(-(m_log_tau_vec[i]-pred_vec[i]))
  }
  log_lik
}

log_Gumbel <- function(resid, nu){
  -nu*resid -exp(-resid)-lgamma(nu)
}

compute_log_lik_approx <- function(m_log_tau_vec, pred_vec, m, v, w){
  log_lik<-numeric(length(m_log_tau_vec))
  for(i in 1:length(m_log_tau_vec)){
    log_lik[i] <- log(sum(w*dnorm(x = m_log_tau_vec[i],mean = pred_vec[i]+m,sd = sqrt(v) )))
  }
  
  log_lik
}


#####################################################
## campiona con mistura originaria
sample_aux <- function(lam, y_s, 
                        m_mix, v_mix, w_mix){
  
  tau <- NULL
  lam_exp<-NULL
  for(i in 1:length(y_s)){
    if(y_s[i]==0){
      tau <- c(tau, 1 + rexp(n = 1, rate = lam[i]))
      lam_exp<-c(lam_exp, lam[i])
    }else{
      u_stat <- runif(n = y_s[i])
      u_stat <-c(0,sort(u_stat))
      tau <- c(tau, diff(u_stat), 1 -sum(diff(u_stat)) + rexp(n = 1, rate = lam[i]))
      lam_exp<-c(lam_exp, rep(lam[i],y_s[i]+1))
    }
  }
  m_1 <- v_1 <-  numeric(length(tau))
  
  for(j in 1:length(tau)){
    probs <- w_mix * dnorm(- log(tau[j]) -
                             log(lam_exp[j]), 
                           m_mix, 
                           sqrt(v_mix))
    r_1 <- sample(1:length(m_mix), 1, prob = probs)
    m_1[j] <- m_mix[r_1]
    v_1[j] <- v_mix[r_1]
  }
  cbind(tau, m_1, v_1)
}

###################################
## Campionatore mistura POISSON

# diversi coefficienti per la mistura

sample_Poi_aux <- function(y, X, lam_init,
                           prec_fix = .0002, nmc = 10000,
                           par_mix){
  ord <- order(y)
  y_s <- y[ord]
  X_s <- X[ord,]
  lam_s <- lam_init[ord]
  X_mix <- matrix(nrow=0, ncol=ncol(X_s))
  for(i in 1:length(y_s)){
    if(y_s[i]==0){
      X_mix<-rbind(X_mix, X_s[i,])
    }else{
      X_appo<-matrix(rep(X_s[i,],y_s[i]+1), nrow = y_s[i]+1, ncol= ncol(X), byrow = T)
      X_mix<-rbind(X_mix, X_appo)
    }
  }
  Q_pri_beta <- prec_fix * diag(ncol(X_mix))
  # init quantities
  lam_s_mcmc<- lam_s
  beta_store <- matrix(NA, nmc, ncol(X_mix))
  m_log_tau_store <- matrix(NA, nmc, nrow(X_mix))
  lambda_store <- matrix(NA, nmc, nrow(X_mix))
  log_lik <- matrix(nrow = nmc, ncol = nrow(X_mix))
  log_lik_approx <- matrix(nrow = nmc, ncol = nrow(X_mix))
  
  
  for(k in 1:nmc){
    appo <- sample_aux(unique(lam_s_mcmc), y_s,
                                     par_mix$m, par_mix$s2, par_mix$w)
    
    y_aux <- m_log_tau_store[k,] <- - log(appo[,1])
    m_aux <- appo[,2]
    vars_aux <- appo[,3]
    Q_beta_fc <- (t(X_mix) %*% diag(1 / vars_aux) %*% X_mix + Q_pri_beta) 
    mu_beta_fc <- solve(Q_beta_fc) %*% t(X_mix) %*% diag(1 / vars_aux) %*% (y_aux - m_aux)
    beta_samp <- c(mvtnorm::rmvnorm(1, mu_beta_fc, solve(Q_beta_fc)))
    lam_s_mcmc <- lambda_store[k,] <- exp(X_mix %*% beta_samp)
    beta_store[k, ] <- beta_samp
    log_lik[k,] <- compute_log_lik(m_log_tau_store[k,],pred_vec = log(lambda_store[k,]))
    log_lik_approx[k,] <- compute_log_lik_approx(m_log_tau_store[k,],pred_vec = log(lambda_store[k,]),par_mix$m, par_mix$s2, par_mix$w)
    if(k%%100 == 0) print(k)
  }
  
  list(log_lik = log_lik, 
       log_lik_approx = log_lik_approx,
       beta = beta_store,
       lambda = lambda_store,
       minus_log_tau = m_log_tau_store
       )
  
}

##################################################
##### campiona da "improved auxiliary variable"
## Input: vuole matrice coefficienti

sample_Improved_aux <- function(lam, y_s, n_0, n, 
                                 m_mix, v_mix, w_mix){
  
  loglik_app<- 0
  loglik<- 0
  m_1 <- v_1 <- r_1 <- tau1 <- numeric(n)
  m_2 <- v_2 <- r_2 <- tau2 <- numeric(n - n_0)
  if(n_0>0){
    for(j in 1:n_0){
      xi_i = rexp(1, lam[j]);
      tau1[j] = 1.0 + xi_i;
      probs <- w_mix[1,] * dnorm(- log(tau1[j]) -
                                   log(lam[j]), 
                                 m_mix[1,], 
                                 sqrt(v_mix[1,]))
      r_1 <- sample(1:10, 1, prob = probs)
      m_1[j] <- m_mix[1, r_1]
      v_1[j] <- v_mix[1, r_1]
      loglik_app<-loglik_app+log(sum(w_mix[1,]*dnorm(x = - log(tau1[j]) -log(lam[j]),
                                                     mean = m_mix[1,],sd = sqrt(v_mix[1,]) )))
      loglik <- loglik + log_Gumbel(resid = - log(tau1[j]) -log(lam[j]), nu = 1)
      

    }
  }
  for(j in (n_0+1):n){
    xi_i = rexp(1, lam[j]);
    tau2[j - n_0] = rbeta(1, y_s[j] * 1.0, 1.0);
    tau1[j] = 1.0 - tau2[j - n_0] + xi_i;
    probs <- w_mix[1,] * dnorm(- log(tau1[j]) -
                                 log(lam[j]), 
                               m_mix[1,], 
                               sqrt(v_mix[1,]))
    loglik_app<-loglik_app+log(sum(w_mix[1,]*dnorm(x = - log(tau1[j]) -log(lam[j]),
                                                   mean = m_mix[1,],sd = sqrt(v_mix[1,]) )))
    loglik <- loglik + log_Gumbel(resid = - log(tau1[j]) -log(lam[j]), nu = 1)
    
    r_1 <- sample(1:10, 1, prob = probs)
    m_1[j] <- m_mix[1, r_1]
    v_1[j] <- v_mix[1, r_1]
    
    probs <- w_mix[j - n_0 + 1, ] * dnorm(- log(tau2[j - n_0]) - log(lam[j]), 
                                          m_mix[j - n_0 + 1, ], sqrt(v_mix[j - n_0 + 1, ]))
    loglik_app<-loglik_app+log(sum(w_mix[j - n_0 + 1, ]*dnorm(x = - log(tau2[j - n_0]) - log(lam[j]),
                                                   mean = m_mix[j - n_0 + 1, ],sd = sqrt(v_mix[j - n_0 + 1, ]) )))
    loglik <- loglik + log_Gumbel(resid = - log(tau2[j - n_0]) - log(lam[j]), nu = y_s[j])
    
    r_2 <- sample(1:10, 1, prob = probs)
    m_2[j - n_0] <- m_mix[j - n_0 + 1, r_2]
    v_2[j - n_0] <- v_mix[j - n_0 + 1, r_2]
  }
  
  #print(c(loglik_app, loglik))
  list(res1=cbind(c(tau1, tau2), c(m_1, m_2), c(v_1, v_2)),
       log_lik_app = loglik_app, 
       loglik = loglik)
}


sample_Poi_Improved_aux <- function(y, X, lam_init,
                           prec_fix = .0002, nmc = 10000){
    ord <- order(y)
    y_s <- y[ord]
    X_s <- X[ord,]
    lam_s <- lam_init[ord]
    X_mix <- rbind(X_s, X_s[y_s>0,])
    n_0 <- sum(y == 0)
    n<-length(y)
    mat <- mixcomp_poisson()
    ################################
    ## mistura dentro per ora, non ci sono check su quella
    per_r1 <- compute_mixture(1, mat)
    w_r1 <- per_r1$w
    m_r1 <- per_r1$m
    v_r1 <- per_r1$v
    mix_comps <- vector("list", n)
    for(k in (n_0 + 1):n){
      mix_comps[[k]] <- compute_mixture(y_s[k], mat)
    }
    
    m_r2 <- matrix(unlist(map(
      mix_comps, ~(.$m)
    )), ncol = 10, byrow = T)
    
    v_r2 <- matrix(unlist(map(
      mix_comps, ~(.$v)
    )), ncol = 10, byrow = T)
    
    w_r2 <- matrix(unlist(map(
      mix_comps, ~(.$w)
    )), ncol = 10, byrow = T)
    
    m_mix <- rbind(m_r1, m_r2)
    v_mix <- rbind(v_r1, v_r2)
    w_mix <- rbind(w_r1, w_r2)
    
    Q_pri_beta <- prec_fix * diag(ncol(X_mix))
    lam_s_mcmc<- lam_s
    beta_store <- matrix(NA, nmc, ncol(X_mix))
    m_log_tau_store <- matrix(NA, nmc, nrow(X_mix))
    lambda_store <- matrix(NA, nmc, nrow(X_mix))
    log_lik <- numeric(nmc)
    log_lik_approx <- numeric(nmc)
    
    for(k in 1:nmc){
      appo <- sample_Improved_aux(lam_s_mcmc, y_s, n_0, n,
                                   m_mix, v_mix, w_mix)
      log_lik[k] <- appo$loglik
      log_lik_approx[k] <- appo$log_lik_app
      y_aux <-  m_log_tau_store[k,] <- - log(appo$res1[,1])
      m_aux <- appo$res1[,2]
      vars_aux <- appo$res1[,3]
      Q_beta_fc <- (t(X_mix) %*% diag(1 / vars_aux) %*% X_mix + Q_pri_beta) 
      mu_beta_fc <- solve(Q_beta_fc) %*% t(X_mix) %*% diag(1 / vars_aux) %*% (y_aux - m_aux)
      beta_samp <- c(mvtnorm::rmvnorm(1, mu_beta_fc, solve(Q_beta_fc)))
      lam_s_mcmc <- lambda_store[k,] <- exp(X_mix %*% beta_samp)
      beta_store[k, ] <- beta_samp
      if(k%%100 == 0) print(k)
    }
    list(log_lik = log_lik, 
         log_lik_approx = log_lik_approx,
         beta = beta_store,
         lambda = lambda_store,
         minus_log_tau = m_log_tau_store
    )
    
}


sample_Poi_aux_MH <- function(y, X, lam_init,
                                       prec_fix = .0002, nmc = 10000,
                                       par_mix){
  ord <- order(y)
  y_s <- y[ord]
  X_s <- X[ord,]
  lam_s <- lam_init[ord]
  X_mix <- matrix(nrow=0, ncol=ncol(X_s))
  for(i in 1:length(y_s)){
    if(y_s[i]==0){
      X_mix<-rbind(X_mix, X_s[i,])
    }else{
      X_appo<-matrix(rep(X_s[i,],y_s[i]+1), nrow = y_s[i]+1, ncol= ncol(X), byrow = T)
      X_mix<-rbind(X_mix, X_appo)
    }
  }
  Q_pri_beta <- prec_fix * diag(ncol(X_mix))
  # init quantities
  lam_s_mcmc<- lam_s
  beta_store <- matrix(0, nmc, ncol(X_mix))
  m_log_tau_store <- matrix(0, nmc, nrow(X_mix))
  lambda_store <- matrix(NA, nmc, nrow(X_mix))
  log_lik <- matrix(nrow = nmc, ncol = nrow(X_mix))
  log_lik_approx <- matrix(nrow = nmc, ncol = nrow(X_mix))
  accetta <- numeric(nmc)
  
  for(k in 2:nmc){
    appo <- sample_aux(unique(lam_s_mcmc), y_s,
                       par_mix$m, par_mix$s2, par_mix$w)
    
    y_aux <- m_log_tau_store[k,] <- - log(appo[,1])
    m_aux <- appo[,2]
    vars_aux <- appo[,3]
    epsilons <- y_aux - X_mix %*% beta_store[k-1, ] - m_aux
    Q_beta_fc <- solve(t(X_mix) %*% diag(1 / vars_aux) %*% X_mix + Q_pri_beta) 
    mu_beta_fc <- (Q_beta_fc) %*% t(X_mix) %*% diag(1 / vars_aux) %*% ( X_mix %*% beta_store[k-1, ]+epsilons)
    beta_samp <- c(mvtnorm::rmvnorm(1, mu_beta_fc, (Q_beta_fc)))
    lam_s_mcmc <- lambda_store[k,] <- exp(X_mix %*% beta_samp)
    #beta_store[k, ] <- beta_samp
    log_lik[k,] <- compute_log_lik(m_log_tau_store[k,],pred_vec = log(lambda_store[k,]))
    log_lik_approx[k,] <- compute_log_lik_approx(m_log_tau_store[k,],pred_vec = log(lambda_store[k,]),par_mix$m, par_mix$s2, par_mix$w)

    # Passo MH (?????)
    factor_1 <- sum(compute_log_lik(y_aux, X_mix %*% beta_samp))+ mvtnorm::dmvnorm(x = beta_samp, sigma = solve(Q_pri_beta)) - 
      sum(compute_log_lik(y_aux, X_mix %*% beta_store[k-1, ]))- mvtnorm::dmvnorm(x = beta_store[k-1, ], sigma = solve(Q_pri_beta)) 
    # (Q_beta_fc) %*% t(X_mix) %*% diag(1 / vars_aux) %*% (X_mix%*%beta_samp+epsilons)
    factor_2 <-  mvtnorm::dmvnorm(x = beta_store[k-1, ], mean = (Q_beta_fc) %*% t(X_mix) %*% diag(1 / vars_aux) %*% ( X_mix %*% beta_samp+epsilons), sigma = Q_beta_fc, log=T) - 
      mvtnorm::dmvnorm(x = beta_samp, mean = mu_beta_fc, sigma = Q_beta_fc,  log=T)
      
    
    accept_prob <- min(c(1, exp(factor_1 + factor_2)))
    u <- runif(1)
    accetta[k] <- u < accept_prob
    if(accetta[k]){
       beta_store[k, ] <- beta_samp} else {
         beta_store[k, ] <- beta_store[k-1, ]
       }
    
    if(k%%100 == 0) print(k)
  }
  list(log_lik = log_lik, 
       log_lik_approx = log_lik_approx,
       beta = beta_store,
       lambda = lambda_store,
       minus_log_tau = m_log_tau_store,
       accept = accetta
  )
  
}



##################################################
##### campiona da "improved auxiliary variable"
## Input: vuole matrice coefficienti



